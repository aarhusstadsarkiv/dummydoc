import argparse
import sqlite3
from PIL import Image
from PIL import ImageDraw
from PIL import ImageFont

from sqlite3.dbapi2 import Connection
from typing import List


def dummydoc(file: str) -> None:
    """
    * Takes a path to a database generated by Digiarch

    * Prints a list of every dummy tiff file entry in the database
    """
    # Define checksums to look for, put them in a list
    dummyChecksums: List[str] = []

    # "corrupted file" checksum
    dummyChecksums.append(
        "50a33547e3d47c5dba7282c9e7fd72f96415190131b6326ed72327dc1f966c23"
    )
    # "empty file" checksum
    dummyChecksums.append(
        "86b54cf579de41c77966110c6ea2cebcb463497741c0852c3a2fa0eb6147c6bb"
    )
    # "no known software" checksum
    dummyChecksums.append(
        "7505e62d0e47b61298916e49c394a013a2119527738cc072ad3eb2ae6407a913"
    )
    # "not preservable" checksum
    dummyChecksums.append(
        "180dddb2b4563c84caf9fb8eee919c22388b62d86b875613ecb88423b2a0b696"
    )
    # "password protected" checksum
    dummyChecksums.append(
        "1f02c224c2acc2110a8c04cf1232402ad18bf7a1c5404140dfd6cc1f0f61b764"
    )

    # Create lists for each dummy tiff to house the dummy files we find
    # Pack them in a list?
    dummyLists: List[List[str]] = []
    for i in dummyChecksums:
        dummyLists.append([])
    # This way the structure of the program is extensible and flexible
    # - if the dummy files change or new ones are added, the only thing
    # needed is to update the saved checksums
    # To make it even easier, we COULD actually calculate the checksums,
    # and have a folder with the dummy tiffs - then updating the program
    # would just mean modifying this folder!

    # "Connect" to the .db file
    try:
        con: Connection = sqlite3.connect(
            "file:" + file + "?mode=ro", uri=True
        )
        # Now, query the .db file, and look thru the result
        for path, checksum in con.execute(
            "SELECT aars_path, checksum FROM Files"
        ):
            for idx, dummyChecksum in enumerate(dummyChecksums):
                if checksum == dummyChecksum:
                    dummyLists[idx].append(path)

    # if the path isn't pointing to a valid database file
    except sqlite3.DatabaseError:
        print(
            "Error: "
            + file
            + " isn't a path to a valid Digiarch-produced database!"
        )
        return

    # Create a .tif file documenting the dummy .tifs found
    stringToTiffPrinter(
        unpackDummyLists(dummyLists), file[0:-8] + "dummytiffs.tif"
    )

    # For easier testing, I'll print out how many of each was found too
    print("Found this many corrupted file tifs: " + str(len(dummyLists[0])))
    print("Found this many empty file tifs: " + str(len(dummyLists[1])))
    print("Found this many no known software tifs: " + str(len(dummyLists[2])))
    print("Found this many not preservable tifs: " + str(len(dummyLists[3])))
    print(
        "Found this many password protected tifs: " + str(len(dummyLists[4]))
    )


# Handles the actual printing work!
# Maybe spin it into a module? Then it might
# be useful for printing text files as well
# Just read them into a list, and call this
def stringToTiffPrinter(inputList: List[str], dest: str) -> None:
    """
    * Takes a list of strings to print, and a destination to save it at

    * Creates a tiff at the given destination
      with each string in the list on its own line
    """

    # To figure out the dimensions required for our
    # tiff, we'll need to make an unused test img first
    img: Image = Image.new("1", (5, 5))
    d: ImageDraw = ImageDraw.Draw(img)
    # Calculate how much we need to print,
    # so we can create a tiff of a suitable size
    totalLinesToPrint: int = len(inputList)
    textWidth: int = 0
    textHeight: int = 0

    # We'll also need a font, to calculate size
    # and to actually make the text later!
    textFont = ImageFont.truetype("arial.ttf", 18)

    # Also figure out how tall and wide the strings are gonna be
    for s in inputList:
        tempWidth, tempHeight = d.textsize(s, font=textFont)
        textWidth = max(textWidth, tempWidth)
        textHeight += tempHeight

    textVerticalMargin: int = 10
    textHorizontalMargin: int = 10
    textVerticalSpacing: int = 2

    # Dimensions of image:
    #   Width:  Horizontal margin x 2
    #           + the width of the widest path
    #   Height: Vertical margin x 2
    #           + the height of all the text paths combined
    #           + (the number of paths - 1) x the spacing between each line
    tiffFile: Image = Image.new(
        "1",
        (
            textHorizontalMargin * 2 + textWidth,
            textVerticalMargin * 2
            + textHeight
            + (totalLinesToPrint - 1) * textVerticalSpacing,
        ),
        1,
    )
    tiffDraw: ImageDraw = ImageDraw.Draw(tiffFile)

    # ... and now we can finally draw the image!
    x_pos: int = textHorizontalMargin
    y_pos: int = textVerticalMargin

    for s in inputList:
        tiffDraw.text((x_pos, y_pos), s, fill=0, font=textFont)
        tempWidth, tempHeight = d.textsize(s, font=textFont)
        y_pos += tempHeight + textVerticalSpacing
    # !!! for next time: figure out how to draw it nicer-looking?
    # !!! Maybe some fonts?
    # !!! Also, add headers! Remember to tweak the
    # !!! image size calculations to account for this

    # And then save it
    tiffFile.save(dest)


# simple helper function that "unpacks" the multiple
# dummy lists and converts it into one list
# it also adds very simple "headers"
def unpackDummyLists(dummyLists: List[List[str]]) -> List[str]:
    unpackedList: List[str] = []
    headerList = [
        '"Corrupted"', #korrumperede filer
        '"Empty"', #tomme filer
        '"No known software"', #filer uden en konverteringsløsning
        '"Not preservable"', #ikkebevaringsværdige filer
        '"Password protected"', #kodeordsbeskyttede filer
    ]

    """ 
    Dette er en oversigt over erstatningsdokumenter for digitale filer, som af følgende årsager ikke er blevet konverteret korrekt af Aarhus Stadsarkiv under produktionen af denne arkiveringsverion.
    Der er filer, som ikke er bevaringsværdige, men som ikke blev sorteret fra af leverandøren, før dataudtrækket blev leveret til Aarhus Stadsarkiv.
    Der er også filer, som oprindeligt enten har været tomme eller korrumperede og derfor ikke mulige at reparere, samt kodeordsbeskyttede filer, som det ikke har været muligt at bryde koden på og trække ud det oprindelige system.
    Derudover er der filer, hvor der ikke kunne findes en softwareløsning, som kunne konvertere dem til et bevaringsværdigt format.
    """

    for index, ls in enumerate(dummyLists):
        unpackedList.append(
            headerList[index] + " dummy tiffs: " + str(len(ls)) #"Antallet af erstatningsdokumenter for " + headerList[index] + "er" + str(len(ls)) + "på følgende placeringer:"
        )
        # unpackedList.extend(ls)
        for s in ls:
            unpackedList.append("        " + s)
        unpackedList.append("\n")

    return unpackedList[:-1]  # ignoring the newline right at the end


# Set up argparse stuff
# Not sure if this is where it should go

parser = argparse.ArgumentParser()
parser.add_argument(
    "file",
    help="the path to the database generated by Digiarch that's "
    + "to be searched for dummy tiff files",
    type=str,
)
args: argparse.Namespace = parser.parse_args()
dummydoc(args.file)
